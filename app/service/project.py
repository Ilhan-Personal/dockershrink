from app.service.dockerfile import Dockerfile
from app.service.dockerignore import Dockerignore
from app.service.package_json import PackageJSON


class Project:
    dockerfile: Dockerfile
    dockerignore: Dockerignore
    package_json: PackageJSON

    def __init__(
        self,
        dockerfile: Dockerfile = None,
        dockerignore: Dockerignore = None,
        package_json: PackageJSON = None,
    ):
        self.dockerfile = dockerfile
        self.dockerignore = dockerignore
        self.package_json = package_json

        self.recommendations = []

    def _dockerfile_use_multistage_builds(self):
        # Light base image, preferably NODE_ENV=production, should ideally only copy app code + node_modules
        pass

    def _dockerfile_minimize_layers(self):
        """
        Minimizes the number of layers by combining consecutive RUN statements into a since RUN statement.
        """
        pass

    def _dockerfile_use_node_prune(self):
        """
        Downloads and invokes node-prune as the last step in the second-last stage of the Dockerfile.
        """
        pass

    def _dockerfile_finalstage_use_light_baseimage(self):
        pass

    def _dockerfile_exclude_dev_dependencies(self):
        # ensure npm install --production or yarn install --production
        # alternatively, check if npm prune command is being used
        pass

    def _dockerfile_exclude_frontend_assets(self):
        """
        Determines whether any frontend assets are being packaged inside the image.
        If yes, this rule adds a recommendation to avoid including FE assets in the image.
        FE assets are better served via a CDN or dedicated frontend server (like nginx).
        At the moment, this rule cannot "fix" this in the Dockerfile.
        """
        pass

    def generate_docker_image_definition(self, ai=None):
        return "dockerfile", "dockerignore"

    def optimize_docker_image(self, ai=None):
        """
        Given all assets of the current project, this method optimises
        the Docker image definition for it.

        :return:
        """
        # Ensure that .dockerignore exists and contains the recommended
        # files & directories
        if not self.dockerignore.exists():
            self.dockerignore.create()
        self.dockerignore.add_if_not_present(["node_modules", "npm_debug.log", ".git"])

        # First, we try to include multistage build. Using Multistage builds is always recommended.
        # Because in the final stage, you can just use a light base image, leave out everything and only cherry-pick
        # what you need.
        # Only the things that you consciously include are present, there is no data or apps which were a side effect of
        # some operation.
        # Another benefit of ensuring multistage first is that all other rules execute on the final stage, which is
        # more useful than optimizing previous stages.
        # It doesn't matter if the final stage was already user-provided or generated by dockershrink.
        if self.dockerfile.get_stage_count() == 1:
            self._dockerfile_use_multistage_builds()

        self._dockerfile_minimize_layers()
        self._dockerfile_exclude_dev_dependencies()
        self._dockerfile_use_node_prune()
        self._dockerfile_finalstage_use_light_baseimage()
        self._dockerfile_exclude_frontend_assets()

        return {
            "recommendations": self.recommendations,
            "modified_project": {
                "Dockerfile": self.dockerfile.raw(),
                ".dockerignore": self.dockerignore.raw(),
                "package.json": self.package_json.raw(),
            },
        }
